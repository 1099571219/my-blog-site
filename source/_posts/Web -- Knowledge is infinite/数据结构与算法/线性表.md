---
title: 线性表
categories:
  - [Web -- Knowledge is infinite, 数据结构与算法]
tag: 数据结构与算法
date: 2023-12-12
mermaid: true
mainTextColor: "00695c"
---

# 线性表

## 线性表的定义

**<font color="#1565c0">线性表（List）：零个或多个数据元素的有限序列</font>**

首先它是一个序列，也就是说，元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后驱，其他每一个元素都有且只有一个前驱和后驱

然后，线性表强调是有限的，事实上，计算机中处理的对象都是有限的，那种无限的数列，只存在于数学模型

```mermaid
graph LR
    节点1((A1)) --> 节点2((A2)) --> 节点3((A3)) --> 节点4((A4)) --> 节点5((A5)) -.-> 节点6((An))

 style 节点1 fill:#b71c1c,color:white,stroke:none;
    style 节点2 fill:#ff8f00,color:white,stroke:none;
    style 节点3 fill:#455a64,color:white,stroke:none;
    style 节点4 fill:#00695c,color:white,stroke:none;
    style 节点5 fill:#0277bd,color:white,stroke:none;
    style 节点6 fill:#0d47a1,color:white,stroke:none;
```

A2 为 A3 **<font color="#1565c0">的直接前驱元素</font>** ，A2 为 A1 的 **<font color="#1565c0">直接后继元素</font>**

线性表元素的个数 n (n >= 0) 定义为 **<font color="#1565c0">线性表的长度</font>** ，当 n = 0 时，称为 **<font color="#1565c0">空表</font>**

在非空表中的每个数据元素都有一个确定的位置，如 A1 是第一个数据元素，An 是最后一个数据元素，Ai 是第 i 个数据元素，称 i 为数据元素 Ai 在线性表中的 **<font color="#1565c0">位序</font>**

举个例子，一些数据集，判断一下是否是线性表

一年里的星座列表，算不算线性表呢，如下图：

```mermaid
graph LR
    节点1((白羊)) --> 节点2((金牛)) --> 节点3((双子)) --> 节点4((巨蟹)) --> 节点5((狮子)) --> 节点6((处女)) --> 节点7((天秤)) --> 节点8((天蝎)) --> 节点9((射手)) --> 节点10((摩羯)) --> 节点11((水瓶)) --> 节点12((双鱼))

 style 节点1 fill:#b71c1c,color:white,stroke:none;
    style 节点2 fill:#ff8f00,color:white,stroke:none;
    style 节点3 fill:#455a64,color:white,stroke:none;
    style 节点4 fill:#00695c,color:white,stroke:none;
    style 节点5 fill:#0277bd,color:white,stroke:none;
    style 节点6 fill:#0d47a1,color:white,stroke:none;
    style 节点7 fill:#b71c1c,color:white,stroke:none;
    style 节点8 fill:#ff8f00,color:white,stroke:none;
    style 节点9 fill:#455a64,color:white,stroke:none;
    style 节点10 fill:#00695c,color:white,stroke:none;
    style 节点11 fill:#0277bd,color:white,stroke:none;
    style 节点12 fill:#0d47a1,color:white,stroke:none;
```

当然算，星座通常都是用白羊座打头，双鱼座收尾，当中的星座都有前驱和后继，而且一共也只有 12 个，所以它完全符合线性表的定义

**<font color="#1565c0">在较为复杂的线性表中，一个数据元素可以由若干个数据项组成</font>** ，如图：

```mermaid
classDiagram
    class 学号{
      1
      2
      3
      ...
    }
    class 姓名{
        张三
        李四
        王五
        ...
    }
    class 性别{
      男
      女
      女
      ...
    }
    class 出生年月{
      1996.3
      1994.5
      1995.8
      ...
    }
    class 家庭地址{
      东街西巷4号502室
      南路5井3号5室
      北大街123号
      ...
    }
```

## 线性表的抽象数据类型 ADT

比如，老师为了让小朋友有秩序地出入，所以就考虑给他们排一个队，并且是长期使用的顺序，这个考虑和安排的过程其实就是一个线性表的 **<font color="#1565c0">创建和初始化</font>** 的过程

一开始没经验，把小朋友排好队后，发现有的高有的矮，队伍不好看，于是就让小朋友解散重新排————这是一个线性表 **<font color="#1565c0">重置为空</font>** 的操作

排好了队，随时可以叫出队伍某一位置的小朋友名字及他的具体情况。比如有家长问，队伍里的第五个孩子，怎么这么调皮，他叫什么名字啊，老师可以很快告诉这位家长，这就是万叶的儿子，叫千叶，我在旁边就非常扭捏，看来是我给儿子的名字没取好，儿子让班级脚趾扣地了，这种可以 **<font color="#1565c0">根据位序得到数据元素</font>** 也是一种很重要的线性表操作

还有什么呢？有时我们想知道，某个小朋友，比如可莉是否是班里的小朋友，老师会告诉我说，不是，可莉在蒲公英幼儿园里，不在我们幼儿园。这种 **<font color="#1565c0">查找某个元素是否存在</font>** 的操作很常用

而后有家长问老师，班里现在到底有多少个小朋友呀，这种获得 **<font color="#1565c0">线性表长度</font>** 的问题也很普遍

显然，对于一个幼儿园来说，加入一个新的小朋友到队列中，或因某个小朋友生病，需要移除某个位置，都是很正常的情况。对于一个线性表来说， **<font color="#1565c0">插入数据和删除数据</font>** 都是必须的操作

所以，线性表的抽象数据类型定义如下：

ADT 线性表（List)
Data
线性表的数据对象集合为（A1，A2，……，An)，每个元素的类型均为 DataType。其中，除第一个元素 A1 外，每一个元素有且只有一个直接前驱元素，除了最后一个元素 An 外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。

```
Operation
InitList(L）：初始化操作，建立一个空的线性表工
ListEmpty(L)：若线性表为空，返回true，否则返回falseo
ClearList(L）：将线性表清空
GetElem（L，1，e）：将线性表工中的第个位置元素值返回给e
locateElem（L，e)：在线性表工中查找与给定值e相等的元素，如果查找成功，返回
该元素在表中序号表示成功；否则，返回0表示失败
Listinsert(L，i,e）：在线性表工中的第个位置插入新元素e
ListDelete(L，i，e)：删除线性表工中第主个位置元素，并用e返回其值
ListLength(L）：返回线性表工的元素个数
```

## 线性表的顺序存储结构

### 顺序存储的定义

**<font color="#1565c0">线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素</font>**

线性表（A1,A2,...,An） 的顺序存储结构如下：

```mermaid
graph LR
    subgraph 连续地址
        subgraph A1
        end
        subgraph A2
        end
        subgraph ...
        end
        subgraph Ai-1
        end
        subgraph Ai
        end
         subgraph ....
        end
         subgraph An
        end
    end
    style A1 fill:#b71c1c,color:white,stroke:none;
    style A2 fill:#ff8f00,color:white,stroke:none;
    style Ai-1 fill:#455a64,color:white,stroke:none;
    style Ai fill:#00695c,color:white,stroke:none;
    style An fill:#0277bd,color:white,stroke:none;
    style ... fill:none,stroke:none;
    style .... fill:none,stroke:none;
    style 连续地址 fill:none,stroke-dashArray:5 5;
```

### 顺序存储方式

比如，在大学时，某宿舍有一个同学，人特别老实、热心，时常会帮舍友去图书馆占座，一个宿舍连他共有九个人。他每次一吃完早饭就冲去图书馆，挑一个好地儿，把他书包里的书，一本一本地按座位放好，若书包里的书不够，他会把他的饭盒、水杯、水笔都用上，长长一排，九个座硬是被他占了

线性表的顺序存储结构，和上面例子一样，就是在内存中找了块地儿，通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。既然线性表的每个数据元素的类型都相同，所以可以用 **<font color="#1565c0">一维数组来实现顺序存储结构</font>** ，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置

那同学占座时，如果图书馆里空座很多，他当然不必一定要选择第一排第一个位子，而是可以选择环境好的地儿。找到后，放一个书包在第一个位置，就表示从这开始，这地方暂时归我了。为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是 **<font color="#1565c0">存储空间的起始位置</font>**

接着，因为一共九个人，所以他需要占九个座。线性表中，我们估算这个线性表的最大存储容量，建立一个数组，数组的长度就是这个 **<font color="#1565c0">最大存储容量</font>**

可现实中，宿舍总有那么几个不是很好学的人，为了游戏，为了恋爱，就不去图书馆自习了。假设有九个人，去了六个，真正被使用的座位也就只是六个，另三个是空的。同样地，已经有了起始的位置，也有了最大的容量，于是我们可以在里面增加数据了。随着数据的插入，我们线性表的长度开始变大，不过线性表的当前长度不能超过 **<font color="#1565c0">存储容量</font>** ，即数组的长度。想想也是，如果我们有十个人，只有九个座，自然是坐不下的

到现在为止，发现描述顺序存储结构需要三个属性：

- 存储空间的起始位置：如数组的存储位置就是存储空间的存储位置
- 线性表的最大存储容量：如数组最大长度
- 线性表的当前长度

### 数组长度与线性表长度的区别

这里有两个概念“数组的长度”和“线性表的长度”需要区分一下

数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。有人可能会问，数组的大小一定不可以变吗？我怎么看到有书中谈到可以动态分配的一维数组。是的，一般高级语言，比如 C、VB、C++都可以用编程手段实现动态分配数组，不过这会带来性能上的损耗

线性表的长度是线性表中数据元素的个数， **<font color="#1565c0">随着线性表插入和删除操作</font>** 的进行，这个量是 **<font color="#1565c0">变化</font>** 的

在任意时刻，线性表的长度应该 **<font color="#1565c0">小于等于数组的长度</font>**

### 地址计算方法

由于我们数数都是从 1 开始数的，线性表的定义也不能免俗，起始也是 1，可不管是 C 还是 JS 等语言中的数组却是从 0 开始第一个下标的，于是线性表的第 i 个元素是要存储在数组下标为 i -1 的位置，即数据元素的序号和存放它的数组下标之间存在对应关系

```mermaid

graph TB
    subgraph 连续地址
        subgraph A1
        end
        subgraph A2
        end
        subgraph ...
        end
        subgraph Ai-1
        end
        subgraph Ai
        end
         subgraph ....
        end
         subgraph An
        end
    end
    A1 -.- 0
    A2 -.- 1
    Ai-1 -.- i-2
    Ai -.- i-1
    An -.- n-1
    style A1 fill:#b71c1c,color:white,stroke:none;
    style A2 fill:#ff8f00,color:white,stroke:none;
    style Ai-1 fill:#455a64,color:white,stroke:none;
    style Ai fill:#00695c,color:white,stroke:none;
    style An fill:#0277bd,color:white,stroke:none;
    style ... fill:none,stroke:none;
    style .... fill:none,stroke:none;
    style 连续地址 fill:none,stroke-dashArray:5 5;
```

用数组存储顺序表意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度

其实，内存中的地址，就和图书馆或电影院里的座位一样，都是有编号的。 **<font color="#1565c0">存储器中的每个存储单元都有自己的编号，这个编号称为地址</font>** 。当我们占座后，占座的第一个位置确定后，后面的位置都是可以计算的。试想一下，我是班级成绩第五名，我后面的 10 名同学成绩名次是多少呢？当然是 6，7，…，15，由于每个数据元素，不管它是整型、实型还是字符型，它都是需要占用一定的存储单元空间的。假设每个数据元素占用的是 c 个存储单元，那么线性表中第 i+1 个数据元素的存储位置和第 i 个数据元素的存储位置满足下列关系（LOC 表示获得存储位置的函数）

**<font color="#1565c0">LOC(A~i+1~) = LOC(A~i~) + c</font>**

所以对于第 i 个数据元素 A~i~，的存储位置可以由 A~1~，推算得出：

**<font color="#1565c0">LOC(A~i~) = LOC(A~1~) + (i-1) \* c</font>**

通过这个公式，你可以随时算出线性表中任意位置的地址，不管它是第一个还是最后一个，都是相同的时间。那么我们对每个线性表位置的存入或者取出数据，对于计算机来说都是相等的时间，也就是一个常数，因此用算法中学到的时间复杂度的概念来说，它的存取时间性能为 O(1)。我们通常把具有这一特点的存储结构称为 **<font color="#1565c0">随机存取结构</font>**

## 顺序存储结构的插入与删除

### 获取元素操作

对于线性表的顺序存储结构来说，如果我们要实现 GetElem 操作，即将线性表 L 中的第 i 个位置元素值返回，其实是非常简单的。就程序而言，只要 i 的数值在数组下标范围内，就是把数组第 i-1 下标的值返回即可

```typescript
#define OK 1
#define ERROR 0
/*Status是函致的类型，其值是函数结果状态代码，如OK等 */
type Status = OK | ERROR;
/*初始条件：顺序线性表L已存在，1si≤ListLength(L）*/
/*操作结果：用e返回L中第1个数据元素的值，注意i是指位置，第1个位置的数组是从0开始*/
function GetElem(L:Array,i:number,e):Status{
    if(L.length==0 || i <1 || i>=L.length)return Error;
    e=L[i-1];
    return e;
}
```

### 插入操作

刚才我们也谈到，这里的时间复杂度为 O(1)

举个例子，本来我们在春运时去买火车票，大家都排队排得好好的。这时来了一个抱着孩子的年轻妈妈，对着队伍中排在第三位的你说，“大哥，求求你帮帮忙，我家母亲有病，我得急着回去看她，你看我还抱着孩子，这队伍这么长，你可否让我排在你的前面？”你心一软，就同意了。这时，你必须得退后一步，否则她是没法进到队伍里来的。这可不得了，后面的人像蠕虫一样，全部都得退一步。骂声四起。但后面的人也不清楚这加塞是怎么回事，没什么办法

这个例子其实已经说明了线性表的顺序存储结构，在插入数据时的实现思路:

1. 如果插入位置不合理，抛出异常
2. 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量
3. 从最后一个元素开始向前遍历到第 i 个位置，分别将它们都向后移动一个位置
4. 将要插入元素填入位置 i 处
5. 表长加 1

```typescript
/*初始条件：顺序线性表L已存在，1si≤ListLength(L)，*/
/*操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1*/
function ListInsert(L: Array, i: number, e): Status {
  let k;
  if (L.length == MAXSIZE) return ERROR;
  if (i < 1 || i > L.length + 1) return ERROR;
  if (i <= L.length) {
    for (k = L.length - 1; k >= i - 1; k--) {
      L[k + 1] = L[k];
    }
  }
  L[i - 1] = e;
  L.length++;
  return L;
}
```

### 删除操作

思路：

1. 如果删除位置不合理，抛出异常
2. 取出删除元素
3. 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
4. 表长减 1

```javascript
/*初始条件：顺序线性表L已存在，1si≤ListLength(L)，*/
/*操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1*/
function listDelete(L, i, e) {
  let k;
  if (L.length == 0) return Error;
  if (i < 1 || i > L.length) return Error;
  e = L[i - 1];
  if (i < L.length) {
    for (k = i; k < L.length; k++) {
      L[k - 1] = L[k];
    }
  }
  L.length--;
  return e;
}
```

分析一下，插入和删除的时间复杂度

先看最好的情况，如果元素要插入到或删除最后一个元素，此时时间复杂度为 O(1) ,因为不需要移动元素，就如同来了一个新人要正常排队，当然是排在最后，如果此时他又不想排了，那么他一个人离开就好了，不影响任何人

最坏的情况呢，如果元素要插入到第一个位置或者删除第一个元素，此时时间复杂度是多少呢？这就意味着要移动所有的元素向后或者向前，所以这个时间复杂度为 O(n)

至于平均的情况，由于元素插入到第i个位置，或删除第i个元素，需要移动n一i个元素。根据概率原理，每个位置插入或删除元素的可能性是相同的，也就说位置靠前，移动元素多，位置靠后，移动元素少。最终平均移动次数和最中间的那个元素的移动次数相等，为 $$\frac{n-1}{2}$$

算法篇有学过时间复杂度的推导，可以得出，平均时间复杂度还是 O(n)

这说明线性表的顺序存储结构，在读数据时，不管是哪个位置，时间复杂度都是 O(1)；而插入或删除时，时间复杂度都是 O(n)。这就说明，它比较适合元素个数不太变化，而更多是存取数据的应用。当然，它的优缺点还不只这些

### 线性表顺序存储结构的优缺点
**优点** ：

* 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
* 可以快速地存取表中任一位置的元素

**缺点** ：

* 插入和删除操作需要移动大量元素
* 当线性表长度变化较大时，难以确定存储空间的容量
* 造成存储空间的“碎片”

## 线性表的链式存储结构

### 顺序存储结构不足的解决办法

前面线性表的顺序存储结构，最大的缺点就是插入和删除时需要移动大量元素，这显然就需要耗费时间

要解决这个问题，就得考虑一下导致这个问题的原因

为什么当插入和删除时，需要移动大量元素，仔细分析后，发现原因就在于相邻两元素的存储位置也具有邻居关系，它们的编号是1,2,3，...，n，它们在内存中的位置也是挨着的，中间没有空隙，当然就无法快速插入，而删除后，当中就会留出空隙，自然需要弥补，问题就出在这里

A同学思路：让当中每个元素之间都留有一个空位置，这样要插入时，就不至于移动。可一个空位置如何解决多个相同位置插入数据的问题呢？所以这个想法显然不行

B同学思路：那就让当中每个元素之间都留足够多的位置，根据实际情况制定空隙大小，比如10个，这样插入时，就不需要移动了。万一10个空位用完了，再考虑移动使得每个位置之间都有10个空位置。如果删除，就直接删掉，把位置留空即可。这样似乎暂时解决了插入和删除的移动数据问题。可这对于超过10个同位置数据的插入，效率上还是存在问题。对于数据的遍历，也会因为空位置太多而造成判断时间上的浪费。而且显然这里空间复杂度还增加了，因为每个元素之间都有若干个空位置

**<font color="#1565c0">C同学思路</font>** ：我们反正也是要让相邻元素间留有足够余地，那干脆所有的元素都不要考虑相邻位置了，哪有空位就到哪里，而只是让每个元素知道它下一个元素的位置在哪里，这样，我们可以在第一个元素时，就知道第二个元素的位置（内存地址），而找到它；在第二个元素时，再找到第三个元素的位置（内存地址）。这样所有的元素我们就都可以通过遍历而找到

好！太棒了，这个想法非常好！C同学，你可惜生晚了几十年，不然，你的想法对于数据结构来讲就是划时代的意义。我们要的就是这个思路。

### 线性表链式存储结构定义

线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这就意味着，这些数据元素 **<font color="#1565c0">可以存在内存未被占用的任意位置</font>**

以前在顺序结构中，每个数据元素只需要存储数据元素信息就可以了。现在链式结构中，除了要存储数据元素信息外，还要存储它的 **<font color="#1565c0">后继元素的存储地址</font>**

因此，为了表示每个数据元素A,与其直接后继数据元素A，之间的逻辑关系，对数据元素A来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）我们把存储数据元素信息的域称为 **<font color="#1565c0">数据域</font>** ，把存储直接后继位置的域称为 **<font color="#1565c0">指针域</font>** 。指针域中存储的信息称作 **<font color="#1565c0">指针或链</font>** 。这两部分信息组成数据元素A的 **<font color="#1565c0">存储映像</font>** ，称为 **<font color="#1565c0">结点 (Node）</font>**

**<font color="#1565c0">n个结点（A~1~的存储映像）链结成一个链表，即为线性表（A~1~,A~2~，...，A~n~）的链式存储结构</font>** ，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。单链表正是通过每个结点的指针域将线性表的数据元素按其逻辑次序链接在一起

对于线性表来说，总得有个头有个尾，链表也不例外。我们把 **<font color="#1565c0">链表中第一个结点的存储位置叫做头指针</font>** ，那么整个链表的存取就必须是从头指针开始进行了。之后的每一个结点，其实就是上一个的后继指针指向的位置。想象一下，最后一个结点，它的指针指向哪里？

最后一个，当然就意味着直接后继不存在了，所以我们规定，线性链表的最后一个结点指针为“空”

有时，我们为了更加方便地对链表进行操作，会在 **<font color="#1565c0">单链表的第一个结点前附设一个结点，称为头结点</font>** 。头结点的数据域可以不存储任何信息，谁叫它是第一个呢，有这个特权。也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针


**<font color="#1565c0"></font>**
